--- START FILE TREE ---
Exported File Structure:
.
├── .github
│   └── workflows
│       └── test.yml
├── LICENSE
├── README.md
├── filesystem
│   └── filesystem.go
├── fsglob.go
├── fsglob_internal_test.go
├── fsglob_test.go
├── go.mod
└── testutil
    └── assert.go
--- END FILE TREE ---

--- START FILE: .github/workflows/test.yml ---
name: Run Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'

    - name: Run tests
      run: go test -v ./...
--- END FILE: .github/workflows/test.yml ---

--- START FILE: LICENSE ---
MIT License

Copyright (c) 2025 Igor Bayerl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--- END FILE: LICENSE ---

--- START FILE: README.md ---
# fsglob

[![Go Reference](https://pkg.go.dev/badge/github.com/IgorBayerl/fsglob.svg)](https://pkg.go.dev/github.com/IgorBayerl/fsglob)
[![Go Report Card](https://goreportcard.com/badge/github.com/IgorBayerl/fsglob)](https://goreportcard.com/report/github.com/IgorBayerl/fsglob)
[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT)

`fsglob` is a Go package for finding file paths that match glob patterns. It operates by walking a filesystem and is designed to be cross-platform and extensible.

## Features

-   **Standard Glob Patterns:** Supports common glob syntax for flexible matching.
-   **Cross-Platform Path Handling:** Automatically handles both Windows (`\`) and Unix (`/`) path separators in patterns.
-   **Extensible Filesystem:** Can operate on any filesystem that implements the provided `filesystem.Filesystem` interface, making it suitable for testing with mocks or for use with virtual filesystems.

## Installation

```bash
go get github.com/your-username/fsglob
```

## Quick Start

The main function in this package is `fsglob.GetFiles()`. It takes a pattern and returns a slice of all matching file and directory paths.

```go
package main

import (
	"fmt"
	"log"

	"github.com/your-username/fsglob"
)

func main() {
	// Example 1: Find all Go files recursively from the current directory.
	goFiles, err := fsglob.GetFiles("**/*.go")
	if err != nil {
		log.Fatalf("Failed to find Go files: %v", err)
	}

	fmt.Println("Found Go files:")
	for _, file := range goFiles {
		fmt.Println(file)
	}

	// Example 2: Find all Markdown or text files in a 'docs' directory.
	docFiles, err := fsglob.GetFiles("docs/*.{md,txt}")
	if err != nil {
		log.Fatalf("Failed to find doc files: %v", err)
	}

	fmt.Println("\nFound documentation files:")
	for _, file := range docFiles {
		fmt.Println(file)
	}
}
```

## Pattern Matching Details

`fsglob` supports the following pattern syntax:

| Pattern | Description                                                               | Example                  |
| :------ | :------------------------------------------------------------------------ | :----------------------- |
| `*`     | Matches any sequence of characters, except for path separators (`/` or `\`). | `*.log`                  |
| `?`     | Matches any single character.                                             | `file?.txt`              |
| `**`    | Matches zero or more directories, files, and subdirectories recursively.  | `reports/**/*.xml`       |
| `[]`    | Matches any single character within the brackets. Can be a set or a range. | `[abc].go`, `[0-9].txt`  |
| `{}`    | Matches any of the comma-separated patterns within the braces.            | `image.{jpg,png,gif}`    |

## Advanced Usage: Custom Filesystem

For testing or working with virtual filesystems (e.g., in-memory, TAR files), you can use `fsglob.NewGlob()` to create a globber instance that operates on a custom filesystem.

Your custom filesystem must implement the `filesystem.Filesystem` interface, which is exposed by `github.com/your-username/fsglob/filesystem`.

```go
package main

import (
	"fmt"
	"log"

	"github.com/your-username/fsglob"
	"github.com/your-username/fsglob/filesystem"
)

// InMemoryFS is a simple in-memory implementation of filesystem.Filesystem.
// (This is a conceptual example; a full implementation is required).
type InMemoryFS struct {
    // ... fields to store files and directories in memory
}

// Implement the methods of the filesystem.Filesystem interface for InMemoryFS...
func (fs *InMemoryFS) Stat(name string) (fs.FileInfo, error) { /* ... */ }
func (fs *InMemoryFS) ReadDir(name string) ([]fs.DirEntry, error) { /* ... */ }
func (fs *InMemoryFS) Getwd() (string, error) { /* ... */ }
func (fs *InMemoryFS) Abs(path string) (string, error) { /* ... */ }
// ... other methods

func main() {
	// 1. Create an instance of your custom filesystem.
	memFS := &InMemoryFS{}
	// ... code to populate memFS with files and directories ...

	// 2. Create a new Glob instance with the custom filesystem.
	g := fsglob.NewGlob("/**/*.log", memFS)

	// 3. Use the Expand() method to find matches.
	matches, err := g.Expand()
	if err != nil {
		log.Fatalf("Error during glob expansion: %v", err)
	}

	fmt.Println("Log files found in the in-memory filesystem:")
	for _, match := range matches {
		fmt.Println(match)
	}
}
```

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.
--- END FILE: README.md ---

--- START FILE: filesystem/filesystem.go ---
// Package filesystem provides abstractions for filesystem operations to enable
// easier testing and mocking of file system interactions.
package filesystem

import (
	"io"
	"io/fs"
	"os"
	"path/filepath"
)

// Platformer provides a way for filesystem implementations to indicate
// what platform or environment they are simulating. This is particularly
// useful for mocks that need to simulate different operating systems.
type Platformer interface {
	// Platform returns a string identifier for the platform being simulated
	// (e.g., "windows", "linux", "darwin").
	Platform() string
}

// Filesystem defines the interface for filesystem operations that can be
// implemented by both real filesystem implementations and mocks for testing.
// It wraps common filesystem operations from the os and filepath packages.
type Filesystem interface {
	// Stat returns a FileInfo describing the named file.
	// If there is an error, it will be of type *PathError.
	Stat(name string) (fs.FileInfo, error)

	// ReadDir reads the named directory and returns a list of directory entries
	// sorted by filename.
	ReadDir(name string) ([]fs.DirEntry, error)

	// Getwd returns a rooted path name corresponding to the current directory.
	// If the current directory can be reached via multiple paths (due to
	// symbolic links), Getwd may return any one of them.
	Getwd() (string, error)

	// Abs returns an absolute representation of path. If the path is not
	// absolute it will be joined with the current working directory to turn
	// it into an absolute path.
	Abs(path string) (string, error)

	// MkdirAll creates a directory named path, along with any necessary parents,
	// and returns nil, or else returns an error. The permission bits perm are
	// used for all directories that MkdirAll creates.
	MkdirAll(path string, perm fs.FileMode) error

	// Create creates or truncates the named file. If the file already exists,
	// it is truncated. If the file does not exist, it is created with mode 0666
	// (before umask). If successful, methods on the returned file can be used
	// for I/O; the associated file descriptor has mode O_RDWR.
	Create(path string) (io.WriteCloser, error)

	// Open opens the named file for reading. If successful, methods on the
	// returned file can be used for reading; the associated file descriptor
	// has mode O_RDONLY.
	Open(path string) (fs.File, error)

	// ReadFile reads the named file and returns the contents. A successful
	// call returns err == nil, not err == EOF.
	ReadFile(path string) ([]byte, error)

	// WriteFile writes data to the named file, creating it if necessary.
	// If the file does not exist, WriteFile creates it with permissions perm
	// (before umask); otherwise WriteFile truncates it before writing, without
	// changing permissions.
	WriteFile(path string, data []byte, perm fs.FileMode) error
}

// DefaultFS implements the Filesystem interface using the standard `os` and `filepath` packages.
// It represents the real, underlying filesystem of the host operating system.
// This is the concrete implementation used in production code.
type DefaultFS struct{}

// Stat returns a FileInfo describing the named file using os.Stat.
func (DefaultFS) Stat(name string) (fs.FileInfo, error) { return os.Stat(name) }

// ReadDir reads the named directory using os.ReadDir.
func (DefaultFS) ReadDir(name string) ([]fs.DirEntry, error) { return os.ReadDir(name) }

// Getwd returns the current working directory using os.Getwd.
func (DefaultFS) Getwd() (string, error) { return os.Getwd() }

// Abs returns an absolute representation of path using filepath.Abs.
func (DefaultFS) Abs(path string) (string, error) { return filepath.Abs(path) }

// MkdirAll creates a directory and any necessary parents using os.MkdirAll.
func (DefaultFS) MkdirAll(path string, perm fs.FileMode) error { return os.MkdirAll(path, perm) }

// Create creates or truncates the named file using os.Create.
func (DefaultFS) Create(path string) (io.WriteCloser, error) { return os.Create(path) }

// Open opens the named file for reading using os.Open.
func (DefaultFS) Open(path string) (fs.File, error) { return os.Open(path) }

// ReadFile reads the named file and returns the contents using os.ReadFile.
func (DefaultFS) ReadFile(path string) ([]byte, error) { return os.ReadFile(path) }

// WriteFile writes data to the named file using os.WriteFile.
func (DefaultFS) WriteFile(path string, data []byte, perm fs.FileMode) error {
	return os.WriteFile(path, data, perm)
}

--- END FILE: filesystem/filesystem.go ---

--- START FILE: fsglob.go ---
// package fsglob provides functionality for finding files and directories
// by matching their path names against a pattern.
// Aim to support:
//   - `?`: Matches any single character in a file or directory name.
//   - `*`: Matches zero or more characters in a file or directory name.
//   - `**`: Matches zero or more recursive directories.
//   - `[...]`: Matches a set of characters in a name (e.g., `[abc]`, `[a-z]`).
//   - `{group1,group2,...}`: Matches any of the pattern groups.
//
// Case-insensitivity is the default behavior for matching.
package fsglob

import (
	"fmt"
	"log/slog"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"sync"

	"github.com/IgorBayerl/fsglob/filesystem"
)

var (
	// globCharacters are special characters used in glob patterns.
	globCharacters = []rune{'*', '?', '[', ']', '{', '}'}

	// regexSpecialChars are characters that have special meaning in regular expressions.
	// Used when converting glob patterns to regex to know which characters to escape.
	regexSpecialChars = map[rune]bool{
		'[': true, '\\': true, '^': true, '$': true, '.': true, '|': true,
		'?': true, '*': true, '+': true, '(': true, ')': true, '{': true, '}': true,
	}

	// regexOrStringCache caches compiled regular expressions or literal strings
	// derived from glob pattern segments.
	// Key: pattern string + "|" + case-sensitivity_flag (e.g., "pat?tern*|true")
	regexOrStringCache = make(map[string]*RegexOrString)
	// cacheMutex protects concurrent access to regexOrStringCache.
	cacheMutex = &sync.Mutex{}
)

type RegexOrString struct {
	// CompiledRegex is the compiled regular expression if the pattern segment contains wildcards.
	CompiledRegex *regexp.Regexp
	// IsRegex indicates if CompiledRegex is used for matching.
	IsRegex bool
	// LiteralPattern is the original glob pattern segment if it's treated as a literal.
	LiteralPattern string
	// IgnoreCase indicates if matching should be case-insensitive for literal patterns.
	IgnoreCase bool
	// OriginalRegexPattern stores the regex string pattern before compilation (for debugging or special checks).
	OriginalRegexPattern string
}

// IsMatch checks if the input string matches this RegexOrString.
// For regex patterns, it uses the compiled regex.
// For literal patterns, it performs a string comparison, respecting IgnoreCase.
func (ros *RegexOrString) IsMatch(input string) bool {
	if ros.IsRegex {
		return ros.CompiledRegex.MatchString(input)
	}
	if ros.IgnoreCase {
		return strings.EqualFold(ros.LiteralPattern, input)
	}
	return ros.LiteralPattern == input
}

type Glob struct {
	OriginalPattern string
	IgnoreCase      bool
	FS              filesystem.Filesystem
	platform        string
}

func (g *Glob) joinPath(elem1, elem2 string) string {
	if g.platform == "windows" {
		e1s := strings.ReplaceAll(elem1, "\\", "/")
		e2s := strings.ReplaceAll(elem2, "\\", "/")
		joined := path.Join(e1s, e2s)
		return strings.ReplaceAll(joined, "/", "\\")
	}
	return path.Join(elem1, elem2)
}

func (g *Glob) parentDir(p string) string {
	if g.platform == "windows" {
		pWithSlashes := strings.ReplaceAll(p, "\\", "/")
		dirWithSlashes := path.Dir(pWithSlashes)
		return strings.ReplaceAll(dirWithSlashes, "/", "\\")
	}
	return path.Dir(p)
}

// absForPlatform turns a possibly-relative path into an absolute one
// without mixing host-OS separators.
func (g *Glob) absForPlatform(p string) (string, error) {
	if g.isAbsolutePath(p) {
		return g.normalizePathForFS(p), nil
	}

	cwd, err := g.FS.Getwd()
	if err != nil {
		return "", err
	}
	if g.platform == "windows" {
		return g.joinPath(cwd, g.normalizePathForFS(p)), nil
	}
	return path.Clean(path.Join(g.normalizePathForPattern(cwd), p)), nil
}

type GlobOption func(*Glob)

func WithIgnoreCase(v bool) GlobOption { return func(g *Glob) { g.IgnoreCase = v } }

func NewGlob(pattern string, fs filesystem.Filesystem, opts ...GlobOption) *Glob {
	if fs == nil {
		fs = filesystem.DefaultFS{}
	}

	platform := "unix"
	if p, ok := fs.(filesystem.Platformer); ok {
		platform = p.Platform()
	} else if _, ok := fs.(filesystem.DefaultFS); ok {
		if filepath.Separator == '\\' {
			platform = "windows"
		}
	}

	g := &Glob{
		OriginalPattern: pattern,
		IgnoreCase:      false,
		FS:              fs,
		platform:        platform,
	}

	for _, opt := range opts {
		opt(g)
	}

	return g
}

func (g *Glob) String() string { return g.OriginalPattern }

func (g *Glob) ExpandNames() ([]string, error) {
	res, err := g.expandInternal(g.OriginalPattern, false)
	if err != nil && g.IgnoreCase { // tolerant mode
		slog.Warn("Ignoring malformed glob pattern",
			"pattern", g.OriginalPattern, "error", err)
		return []string{}, nil
	}
	return res, err
}

func (g *Glob) Expand() ([]string, error) {
	res, err := g.expandInternal(g.OriginalPattern, false)
	if err != nil && g.IgnoreCase {
		slog.Warn("Ignoring malformed glob pattern",
			"pattern", g.OriginalPattern, "error", err)
		return []string{}, nil
	}
	return res, err
}

func (g *Glob) tryWindowsCaseFold(absPath string, dirOnly bool) ([]string, error) {
	// Normalize to forward slashes for processing with `path` package
	normalizedPath := g.normalizePathForPattern(absPath)
	cleanPath := path.Clean(normalizedPath)

	// Handle root case `C:\` which clean might change to `C:`
	if len(cleanPath) == 2 && cleanPath[1] == ':' {
		cleanPath += "/"
	}

	vol := ""
	rest := cleanPath
	if len(cleanPath) > 1 && cleanPath[1] == ':' {
		vol = cleanPath[:2]
		rest = cleanPath[2:]
	}

	// path.Clean might remove the leading slash. Put it back.
	if vol != "" && !strings.HasPrefix(rest, "/") {
		rest = "/" + rest
	}

	// Split path components
	parts := strings.Split(strings.Trim(rest, "/"), "/")

	cur := vol + `\`
	if vol == "" {
		// Handle UNC paths if necessary, for now assume drive letters
		if strings.HasPrefix(cleanPath, "//") {
			// very basic UNC handling
			parts = strings.Split(strings.TrimPrefix(cleanPath, "//"), "/")
			if len(parts) < 2 {
				return nil, nil
			}
			cur = `\\` + parts[0] + `\` + parts[1]
			parts = parts[2:]
		} else {
			cur = `\`
		}
	}

	// Walk every segment and pick the real-cased name.
	for _, p := range parts {
		if p == "" {
			continue
		}
		entries, err := g.FS.ReadDir(cur)
		if err != nil {
			return nil, nil // unreadable -> give up
		}
		var matched string
		for _, de := range entries {
			if strings.EqualFold(de.Name(), p) {
				matched = de.Name()
				break
			}
		}
		if matched == "" {
			return nil, nil // path element not found
		}
		cur = g.joinPath(cur, matched)
	}

	info, err := g.FS.Stat(cur)
	if err != nil || (dirOnly && !info.IsDir()) {
		return nil, nil
	}
	return []string{cur}, nil
}

// createRegexOrString compiles a glob pattern segment into a RegexOrString instance.
// It uses a cache to store and retrieve compiled regexes or literal patterns
// to avoid redundant compilations.
func (g *Glob) createRegexOrString(patternSegment string) (*RegexOrString, error) {
	hasWildcards := strings.ContainsAny(patternSegment, "*?[]")

	effectiveIC := g.IgnoreCase
	if !hasWildcards && g.platform == "windows" {
		effectiveIC = true
	}

	cacheKey := patternSegment + "|" + fmt.Sprintf("%t", effectiveIC)

	cacheMutex.Lock()
	if cached, ok := regexOrStringCache[cacheKey]; ok {
		cacheMutex.Unlock()
		return cached, nil
	}
	cacheMutex.Unlock()

	if !hasWildcards {
		ros := &RegexOrString{
			IsRegex:        false,
			LiteralPattern: patternSegment,
			IgnoreCase:     effectiveIC,
		}
		cacheMutex.Lock()
		regexOrStringCache[cacheKey] = ros
		cacheMutex.Unlock()
		return ros, nil
	}

	regexPatternStr, err := globToRegexPattern(patternSegment, g.IgnoreCase)
	if err != nil {
		return nil, fmt.Errorf("failed to convert glob segment %q: %w", patternSegment, err)
	}

	re, err := regexp.Compile(regexPatternStr)
	if err != nil {
		return nil, fmt.Errorf("failed to compile regex %q: %w", regexPatternStr, err)
	}

	ros := &RegexOrString{
		CompiledRegex:        re,
		IsRegex:              true,
		LiteralPattern:       patternSegment,
		IgnoreCase:           g.IgnoreCase,
		OriginalRegexPattern: regexPatternStr,
	}
	cacheMutex.Lock()
	regexOrStringCache[cacheKey] = ros
	cacheMutex.Unlock()
	return ros, nil
}

func (g *Glob) isAbsolutePath(path string) bool {
	if g.platform == "windows" {
		return (len(path) >= 3 && path[1] == ':' && (path[2] == '\\' || path[2] == '/')) ||
			strings.HasPrefix(path, "\\\\") ||
			strings.HasPrefix(path, "/")
	}
	return strings.HasPrefix(path, "/")
}

func (g *Glob) normalizePathForFS(p string) string {
	if g.platform == "windows" {
		return strings.ReplaceAll(p, "/", "\\")
	}
	return strings.ReplaceAll(p, "\\", "/")
}

// normalizePathForPattern converts a path to forward slashes for pattern matching
func (g *Glob) normalizePathForPattern(p string) string {
	return strings.ReplaceAll(p, "\\", "/")
}

// expandInternal is the core recursive matching function.
func (g *Glob) expandInternal(pattern string, dirOnly bool) ([]string, error) {
	if pattern == "" {
		return []string{}, nil
	}

	normalizedPattern := g.normalizePathForPattern(pattern)

	if !strings.ContainsAny(normalizedPattern, string(globCharacters)) {
		absPath, err := g.absForPlatform(pattern)
		if err != nil {
			return nil, err
		}

		if g.platform == "windows" {
			paths, _ := g.tryWindowsCaseFold(absPath, dirOnly)
			return paths, nil
		}

		info, err := g.FS.Stat(absPath)
		if err == nil && (!dirOnly || info.IsDir()) {
			return []string{absPath}, nil
		}
		return []string{}, nil
	}

	parent := path.Dir(normalizedPattern)
	child := path.Base(normalizedPattern)

	if parent == "." && !g.isAbsolutePath(normalizedPattern) {
		cwd, err := g.FS.Getwd()
		if err != nil {
			return []string{}, fmt.Errorf("failed to get working directory: %w", err)
		}
		parent = g.normalizePathForPattern(cwd)
	}

	if strings.Count(child, "}") > strings.Count(child, "{") {
		return g.handleCrossSeparatorBrace(normalizedPattern, dirOnly)
	}

	if child == "**" {
		parentDirs, err := g.expandInternal(g.normalizePathForFS(parent), true)
		if err != nil {
			return nil, err
		}
		var allResults []string
		seenPaths := make(map[string]bool)
		for _, pDir := range parentDirs {
			descendants, err := g.getRecursiveDirectoriesAndFiles(pDir, dirOnly)
			if err != nil {
				continue
			}
			if !seenPaths[pDir] {
				info, err := g.FS.Stat(pDir)
				if err == nil {
					if !dirOnly || info.IsDir() {
						allResults = append(allResults, pDir)
						seenPaths[pDir] = true
					}
				}
			}
			for _, d := range descendants {
				if !seenPaths[d] {
					allResults = append(allResults, d)
					seenPaths[d] = true
				}
			}
		}
		return allResults, nil
	}

	return g.processPathSegment(parent, child, dirOnly)
}

// handleCrossSeparatorBrace handles patterns like "{a/b,c}/d.txt"
func (g *Glob) handleCrossSeparatorBrace(normalizedPattern string, dirOnly bool) ([]string, error) {
	groups, err := ungroup(normalizedPattern)
	if err != nil {
		return nil, fmt.Errorf("error ungrouping path '%s': %w", normalizedPattern, err)
	}
	var allResults []string
	seenPaths := make(map[string]bool)
	for _, groupPattern := range groups {
		expanded, err := g.expandInternal(g.normalizePathForFS(groupPattern), dirOnly)
		if err != nil {
			slog.Warn("Error expanding group pattern", "pattern", groupPattern, "error", err)
			continue
		}
		for _, p := range expanded {
			if !seenPaths[p] {
				allResults = append(allResults, p)
				seenPaths[p] = true
			}
		}
	}
	return allResults, nil
}

// processPathSegment is the main workhorse for a standard `parent/child` pattern.
func (g *Glob) processPathSegment(parentPattern, childPattern string, dirOnly bool) ([]string, error) {
	parentForFS := g.normalizePathForFS(parentPattern)
	expandedParentDirs, err := g.expandInternal(parentForFS, true)
	if err != nil {
		return nil, err
	}

	ungroupedChildSegments, err := ungroup(childPattern)
	if err != nil {
		return nil, fmt.Errorf("error ungrouping child segment '%s': %w", childPattern, err)
	}

	var childRegexes []*RegexOrString
	for _, segment := range ungroupedChildSegments {
		ros, err := g.createRegexOrString(segment)
		if err != nil {
			return nil, err
		}
		childRegexes = append(childRegexes, ros)
	}

	var allMatches []string
	seenPaths := make(map[string]bool)

	for _, parentDir := range expandedParentDirs {
		entries, readDirErr := g.FS.ReadDir(parentDir)
		if readDirErr != nil {
			if os.IsNotExist(readDirErr) {
				continue
			}
			slog.Warn("Error reading directory", "directory", parentDir, "error", readDirErr)
			continue
		}

		for _, entry := range entries {
			isDir := entry.IsDir()
			if !dirOnly || isDir {
				for _, ros := range childRegexes {
					if ros.IsMatch(entry.Name()) {
						absEntryPath := g.joinPath(parentDir, entry.Name())
						if !seenPaths[absEntryPath] {
							allMatches = append(allMatches, absEntryPath)
							seenPaths[absEntryPath] = true
						}
						break
					}
				}
			}
		}

		// Handle '.' and '..' matching
		for _, ros := range childRegexes {
			if ros.LiteralPattern == "." {
				if !seenPaths[parentDir] {
					allMatches = append(allMatches, parentDir)
					seenPaths[parentDir] = true
				}
			} else if ros.LiteralPattern == ".." {
				grandParentDir := g.parentDir(parentDir)
				if grandParentDir != parentDir {
					if !seenPaths[grandParentDir] {
						allMatches = append(allMatches, grandParentDir)
						seenPaths[grandParentDir] = true
					}
				}
			}
		}
	}

	return allMatches, nil
}

// globToRegexPattern converts a glob pattern segment to a Go regular expression string.
func globToRegexPattern(globSegment string, ignoreCase bool) (string, error) {
	var regex strings.Builder
	if ignoreCase {
		regex.WriteString("(?i)")
	}
	regex.WriteRune('^')

	if globSegment == "**" {
		regex.WriteString(".*")
	} else {
		globSegment = strings.ReplaceAll(globSegment, "**", ".*")
		inCharClass := false
		for _, r := range globSegment {
			if inCharClass {
				if r == ']' {
					inCharClass = false
				}
				regex.WriteRune(r)
				continue
			}
			switch r {
			case '*':
				regex.WriteString("[^/\\\\]*")
			case '?':
				regex.WriteRune('.')
			case '[':
				inCharClass = true
				regex.WriteRune(r)
			default:
				if _, isSpecial := regexSpecialChars[r]; isSpecial {
					regex.WriteRune('\\')
				}
				regex.WriteRune(r)
			}
		}
		if inCharClass {
			return "", fmt.Errorf("unterminated character class: %s", globSegment)
		}
	}

	regex.WriteRune('$')
	return regex.String(), nil
}

// ungroup handles brace expansion, e.g., "{a,b}c" -> ["ac", "bc"].
func ungroup(path string) ([]string, error) {
	if !strings.Contains(path, "{") {
		return []string{path}, nil
	}

	var results []string
	level := 0
	firstOpenBrace := -1

	for i, char := range path {
		switch char {
		case '{':
			if level == 0 {
				firstOpenBrace = i
			}
			level++
		case '}':
			level--
			if level == 0 && firstOpenBrace != -1 {
				prefix := path[:firstOpenBrace]
				groupContent := path[firstOpenBrace+1 : i]
				suffix := path[i+1:]

				var groupParts []string
				partBuilder := strings.Builder{}
				subLevel := 0
				for _, gc := range groupContent {
					if gc == '{' {
						subLevel++
						partBuilder.WriteRune(gc)
					} else if gc == '}' {
						subLevel--
						partBuilder.WriteRune(gc)
					} else if gc == ',' && subLevel == 0 {
						groupParts = append(groupParts, partBuilder.String())
						partBuilder.Reset()
					} else {
						partBuilder.WriteRune(gc)
					}
				}
				groupParts = append(groupParts, partBuilder.String())

				expandedSuffixes, err := ungroup(suffix)
				if err != nil {
					return nil, err
				}

				for _, gp := range groupParts {
					currentCombinedPrefixPart := prefix + gp
					expandedPrefixParts, err := ungroup(currentCombinedPrefixPart)
					if err != nil {
						return nil, err
					}

					for _, epp := range expandedPrefixParts {
						for _, es := range expandedSuffixes {
							results = append(results, epp+es)
						}
					}
				}
				return results, nil
			}
		}
	}

	if level != 0 {
		return nil, fmt.Errorf("unbalanced braces in pattern: %s", path)
	}
	return []string{path}, nil
}

// getRecursiveDirectoriesAndFiles is a helper for `**`.
func (g *Glob) getRecursiveDirectoriesAndFiles(root string, dirOnly bool) ([]string, error) {
	var paths []string
	queue := []string{root}
	visited := make(map[string]struct{})

	for len(queue) > 0 {
		currentPath := queue[0]
		queue = queue[1:]

		if _, ok := visited[currentPath]; ok {
			continue
		}
		visited[currentPath] = struct{}{}

		entries, err := g.FS.ReadDir(currentPath)
		if err != nil {
			slog.Warn("Error reading directory", "path", currentPath, "error", err)
			continue
		}

		for _, entry := range entries {
			nextPath := g.joinPath(currentPath, entry.Name())
			entryInfo, err := entry.Info()
			if err != nil {
				slog.Warn("Could not get info for entry", "path", nextPath, "error", err)
				continue
			}
			if !dirOnly || entryInfo.IsDir() {
				paths = append(paths, nextPath)
			}
			if entryInfo.IsDir() {
				queue = append(queue, nextPath)
			}
		}
	}
	return paths, nil
}

// GetFiles is the public entry point for globbing.
func GetFiles(pattern string) ([]string, error) {
	if pattern == "" {
		return []string{}, nil
	}
	g := NewGlob(pattern, nil)
	return g.ExpandNames()
}

--- END FILE: fsglob.go ---

--- START FILE: fsglob_internal_test.go ---
package fsglob

import (
	"io"
	"io/fs"
	"path"
	"reflect"
	"sort"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// MockFileInfo implements fs.FileInfo for testing
type MockFileInfo struct {
	name    string
	size    int64
	mode    fs.FileMode
	modTime time.Time
	isDir   bool
}

func (m MockFileInfo) Name() string       { return m.name }
func (m MockFileInfo) Size() int64        { return m.size }
func (m MockFileInfo) Mode() fs.FileMode  { return m.mode }
func (m MockFileInfo) ModTime() time.Time { return m.modTime }
func (m MockFileInfo) IsDir() bool        { return m.isDir }
func (m MockFileInfo) Sys() interface{}   { return nil }

// MockDirEntry implements fs.DirEntry for testing
type MockDirEntry struct {
	name  string
	isDir bool
	info  MockFileInfo
}

func (m MockDirEntry) Name() string               { return m.name }
func (m MockDirEntry) IsDir() bool                { return m.isDir }
func (m MockDirEntry) Type() fs.FileMode          { return m.info.Mode() }
func (m MockDirEntry) Info() (fs.FileInfo, error) { return m.info, nil }

// MockFilesystem implements filesystem.Filesystem for testing
type MockFilesystem struct {
	files     map[string]MockFileInfo
	dirs      map[string][]MockDirEntry
	cwd       string
	platform  string
	separator string
}

func NewMockFilesystem(platform string) *MockFilesystem {
	sep := "/"
	cwd := "/"
	if platform == "windows" {
		sep = `\`
		cwd = `C:\`
	}
	fs := &MockFilesystem{
		files:     make(map[string]MockFileInfo),
		dirs:      make(map[string][]MockDirEntry),
		cwd:       cwd,
		platform:  platform,
		separator: sep,
	}
	fs.AddFile(cwd, true)
	return fs
}

func (m *MockFilesystem) Platform() string {
	return m.platform
}

func (m *MockFilesystem) mockClean(p string) string {
	isUnc := false
	if m.platform == "windows" {
		p = strings.ReplaceAll(p, `\`, `/`)
		if strings.HasPrefix(p, "//") {
			isUnc = true
			p = p[1:]
		}
	}
	cleaned := path.Clean(p)
	if m.platform == "windows" {
		if isUnc {
			cleaned = "/" + cleaned
		}
		cleaned = strings.ReplaceAll(cleaned, `/`, `\`)
		if len(cleaned) == 2 && cleaned[1] == ':' {
			cleaned += `\`
		}
	}
	return cleaned
}

func (m *MockFilesystem) Stat(name string) (fs.FileInfo, error) {
	absName, err := m.Abs(name)
	if err != nil {
		return nil, &fs.PathError{Op: "stat", Path: name, Err: err}
	}
	if info, exists := m.files[absName]; exists {
		return info, nil
	}
	if m.platform == "windows" {
		for p, info := range m.files {
			if strings.EqualFold(p, absName) {
				return info, nil
			}
		}
	}
	return nil, &fs.PathError{Op: "stat", Path: name, Err: fs.ErrNotExist}
}

func (m *MockFilesystem) ReadDir(name string) ([]fs.DirEntry, error) {
	absName, err := m.Abs(name)
	if err != nil {
		return nil, &fs.PathError{Op: "readdir", Path: name, Err: err}
	}

	handleFound := func(entries []MockDirEntry) ([]fs.DirEntry, error) {
		dirEntries := make([]fs.DirEntry, len(entries))
		for i, entry := range entries {
			dirEntries[i] = entry
		}
		return dirEntries, nil
	}

	if entries, exists := m.dirs[absName]; exists {
		return handleFound(entries)
	}

	if m.platform == "windows" {
		for p, entries := range m.dirs {
			if strings.EqualFold(p, absName) {
				return handleFound(entries)
			}
		}
	}

	return nil, &fs.PathError{Op: "readdir", Path: name, Err: fs.ErrNotExist}
}

func (m *MockFilesystem) Getwd() (string, error) {
	return m.cwd, nil
}

func (m *MockFilesystem) isAbs(p string) bool {
	if m.platform == "windows" {
		return (len(p) > 2 && p[1] == ':' && (p[2] == '\\' || p[2] == '/')) || strings.HasPrefix(p, `\`) || strings.HasPrefix(p, `/`)
	}
	return strings.HasPrefix(p, "/")
}

func (m *MockFilesystem) Abs(pathStr string) (string, error) {
	if m.platform == "windows" {
		pathStr = strings.ReplaceAll(pathStr, "/", `\`)
	} else {
		pathStr = strings.ReplaceAll(pathStr, `\`, "/")
	}

	if m.isAbs(pathStr) {
		return m.mockClean(pathStr), nil
	}

	fullPath := m.cwd + m.separator + pathStr
	return m.mockClean(fullPath), nil
}

func (m *MockFilesystem) mockDir(p string) string {
	lastSep := strings.LastIndex(p, m.separator)
	if m.platform == "windows" {
		if len(p) == 3 && p[1] == ':' && p[2] == '\\' {
			return p
		}
	} else {
		if p == "/" {
			return p
		}
	}
	if lastSep <= 0 {
		return p[:1]
	}
	return p[:lastSep]
}

func (m *MockFilesystem) mockBase(p string) string {
	lastSep := strings.LastIndex(p, m.separator)
	if lastSep == -1 {
		return p
	}
	return p[lastSep+1:]
}

func (m *MockFilesystem) AddFile(path string, isDir bool) {
	absPath, _ := m.Abs(path)

	info := MockFileInfo{
		name:    m.mockBase(absPath),
		size:    100,
		mode:    0644,
		modTime: time.Now(),
		isDir:   isDir,
	}
	if isDir {
		info.mode = fs.ModeDir | 0755
		if _, exists := m.dirs[absPath]; !exists {
			m.dirs[absPath] = []MockDirEntry{}
		}
	}
	m.files[absPath] = info

	parent := m.mockDir(absPath)
	if parent != "" && parent != absPath {
		entry := MockDirEntry{
			name:  info.name,
			isDir: isDir,
			info:  info,
		}
		m.dirs[parent] = append(m.dirs[parent], entry)
	}
}

func (m *MockFilesystem) SetCwd(cwd string) {
	absCwd, _ := m.Abs(cwd)
	m.cwd = absCwd
}

// unused methods in this package
func (m *MockFilesystem) MkdirAll(path string, perm fs.FileMode) error               { return nil }
func (m *MockFilesystem) Create(path string) (io.WriteCloser, error)                 { return nil, nil }
func (m *MockFilesystem) Open(path string) (fs.File, error)                          { return nil, nil }
func (m *MockFilesystem) ReadFile(path string) ([]byte, error)                       { return nil, nil }
func (m *MockFilesystem) WriteFile(path string, data []byte, perm fs.FileMode) error { return nil }

// Test helper functions
func setupLinuxFS() *MockFilesystem {
	fs := NewMockFilesystem("unix")
	fs.SetCwd("/home/user")

	// Create directory structure
	fs.AddFile("/home", true)
	fs.AddFile("/home/user", true)
	fs.AddFile("/home/user/documents", true)
	fs.AddFile("/home/user/documents/file1.txt", false)
	fs.AddFile("/home/user/documents/file2.txt", false)
	fs.AddFile("/home/user/documents/report.pdf", false)
	fs.AddFile("/home/user/documents/subdir", true)
	fs.AddFile("/home/user/documents/subdir/nested.txt", false)
	fs.AddFile("/home/user/documents/subdir/deep", true)
	fs.AddFile("/home/user/documents/subdir/deep/file.log", false)
	fs.AddFile("/home/user/pictures", true)
	fs.AddFile("/home/user/pictures/photo1.jpg", false)
	fs.AddFile("/home/user/pictures/photo2.png", false)
	fs.AddFile("/tmp", true)
	fs.AddFile("/tmp/temp1.tmp", false)
	fs.AddFile("/tmp/temp2.tmp", false)

	return fs
}

func setupWindowsFS() *MockFilesystem {
	fs := NewMockFilesystem("windows")
	fs.SetCwd("C:\\Users\\User")

	// Create directory structure
	fs.AddFile("C:\\Users", true)
	fs.AddFile("C:\\Users\\User", true)
	fs.AddFile("C:\\Users\\User\\Documents", true)
	fs.AddFile("C:\\Users\\User\\Documents\\file1.txt", false)
	fs.AddFile("C:\\Users\\User\\Documents\\file2.txt", false)
	fs.AddFile("C:\\Users\\User\\Documents\\report.pdf", false)
	fs.AddFile("C:\\Users\\User\\Documents\\subdir", true)
	fs.AddFile("C:\\Users\\User\\Documents\\subdir\\nested.txt", false)
	fs.AddFile("C:\\Users\\User\\Documents\\subdir\\deep", true)
	fs.AddFile("C:\\Users\\User\\Documents\\subdir\\deep\\file.log", false)
	fs.AddFile("C:\\Users\\User\\Pictures", true)
	fs.AddFile("C:\\Users\\User\\Pictures\\photo1.jpg", false)
	fs.AddFile("C:\\Users\\User\\Pictures\\photo2.png", false)
	fs.AddFile("C:\\Temp", true)
	fs.AddFile("C:\\Temp\\temp1.tmp", false)
	fs.AddFile("C:\\Temp\\temp2.tmp", false)

	return fs
}

func TestRegexOrStringCache(t *testing.T) {
	fs := setupLinuxFS()
	glob := NewGlob("documents/*.txt", fs)

	// First call should populate cache
	ros1, err := glob.createRegexOrString("*.txt")
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}

	// Second call should return cached result
	ros2, err := glob.createRegexOrString("*.txt")
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}

	// Should be the same object (cached)
	if ros1 != ros2 {
		t.Error("Expected cached RegexOrString to be returned")
	}
}

func TestUngroup(t *testing.T) {
	testCases := []struct {
		name     string
		pattern  string
		expected []string
		hasError bool
	}{
		{
			name:     "simple brace expansion",
			pattern:  "{a,b}c",
			expected: []string{"ac", "bc"},
		},
		{
			name:     "no braces",
			pattern:  "abc",
			expected: []string{"abc"},
		},
		{
			name:     "nested braces",
			pattern:  "{a,b{c,d}}",
			expected: []string{"a", "bc", "bd"},
		},
		{
			name:     "multiple groups",
			pattern:  "{a,b}{c,d}",
			expected: []string{"ac", "ad", "bc", "bd"},
		},
		{
			name:     "unbalanced braces",
			pattern:  "{a,b",
			hasError: true,
		},
		{
			name:     "empty group",
			pattern:  "{}",
			expected: []string{""},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			results, err := ungroup(tc.pattern)

			if tc.hasError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			sort.Strings(results)
			sort.Strings(tc.expected)

			if !reflect.DeepEqual(results, tc.expected) {
				t.Errorf("Expected %v, got %v", tc.expected, results)
			}
		})
	}
}

func TestGlobToRegexPattern(t *testing.T) {
	testCases := []struct {
		name       string
		pattern    string
		ignoreCase bool
		expected   string
		hasError   bool
	}{
		{
			name:       "simple asterisk",
			pattern:    "*.txt",
			ignoreCase: false,
			expected:   "^[^/\\\\]*\\.txt$",
		},
		{
			name:       "question mark",
			pattern:    "file?.txt",
			ignoreCase: false,
			expected:   "^file.\\.txt$",
		},
		{
			name:       "case insensitive",
			pattern:    "*.TXT",
			ignoreCase: true,
			expected:   "(?i)^[^/\\\\]*\\.TXT$",
		},
		{
			name:       "character class",
			pattern:    "file[12].txt",
			ignoreCase: false,
			expected:   "^file[12]\\.txt$",
		},
		{
			name:       "double asterisk",
			pattern:    "**",
			ignoreCase: false,
			expected:   "^.*$",
		},
		{
			name:       "unterminated character class",
			pattern:    "file[12.txt",
			ignoreCase: false,
			hasError:   true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result, err := globToRegexPattern(tc.pattern, tc.ignoreCase)

			if tc.hasError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if result != tc.expected {
				t.Errorf("Expected %q, got %q", tc.expected, result)
			}
		})
	}
}

func BenchmarkRegexCache(b *testing.B) {
	fs := setupLinuxFS()
	glob := NewGlob("documents/*.txt", fs)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := glob.createRegexOrString("*.txt")
		if err != nil {
			b.Fatalf("Unexpected error: %v", err)
		}
	}
}

// Test platform-specific path handling
func TestPlatformSpecificPaths(t *testing.T) {
	t.Run("unix_paths", func(t *testing.T) {
		fs := setupLinuxFS()
		glob := NewGlob("/home/user/documents/*.txt", fs)

		if !glob.isAbsolutePath("/home/user/documents/file.txt") {
			t.Error("Expected Unix absolute path to be recognized")
		}

		if glob.isAbsolutePath("relative/path.txt") {
			t.Error("Expected Unix relative path to not be recognized as absolute")
		}

		normalized := glob.normalizePathForPattern("home\\user\\documents")
		expected := "home/user/documents"
		if normalized != expected {
			t.Errorf("Expected %q, got %q", expected, normalized)
		}
	})

	t.Run("windows_paths", func(t *testing.T) {
		fs := setupWindowsFS()
		glob := NewGlob("C:\\Users\\User\\Documents\\*.txt", fs)

		if !glob.isAbsolutePath("C:\\Users\\User\\Documents\\file.txt") {
			t.Error("Expected Windows absolute path to be recognized")
		}

		if !glob.isAbsolutePath(`\\server\share\file.txt`) {
			t.Error("Expected Windows UNC path to be recognized")
		}

		if glob.isAbsolutePath(`relative\path.txt`) {
			t.Error("Expected Windows relative path to not be recognized as absolute")
		}

		normalized := glob.normalizePathForFS("Users/User/Documents")
		expected := `Users\User\Documents`
		if normalized != expected {
			t.Errorf("Expected %q, got %q", expected, normalized)
		}
	})
}

// Test concurrent access to cache
func TestConcurrentCacheAccess(t *testing.T) {
	fs := setupLinuxFS()

	// Run multiple goroutines accessing the cache simultaneously
	done := make(chan bool)
	errors := make(chan error, 10)

	for i := 0; i < 10; i++ {
		go func() {
			defer func() { done <- true }()
			glob := NewGlob("documents/*.txt", fs)
			_, err := glob.createRegexOrString("*.txt")
			if err != nil {
				errors <- err
			}
		}()
	}

	// Wait for all goroutines to complete
	for i := 0; i < 10; i++ {
		<-done
	}

	// Check for errors
	select {
	case err := <-errors:
		t.Fatalf("Unexpected error in concurrent access: %v", err)
	default:
		// No errors, test passed
	}
}

// Test path normalization edge cases
func TestPathNormalizationEdgeCases(t *testing.T) {
	testCases := []struct {
		name     string
		platform string
		input    string
		expected string
	}{
		{
			name:     "windows_mixed_separators",
			platform: "windows",
			input:    "C:/Users\\User/Documents",
			expected: `C:\Users\User\Documents`,
		},
		{
			name:     "unix_backslashes",
			platform: "unix",
			input:    `home\user\documents`,
			expected: "home/user/documents",
		},
		{
			name:     "windows_unc_path",
			platform: "windows",
			input:    "//server/share/file.txt",
			expected: `\\server\share\file.txt`,
		},
		{
			name:     "empty_path",
			platform: "unix",
			input:    "",
			expected: "",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			fs := NewMockFilesystem(tc.platform)
			glob := NewGlob("test", fs)

			result := glob.normalizePathForFS(tc.input)
			if tc.name == "windows_unc_path" {
				// This specific test case requires a different normalizer since it's not a standard path
				assert.Equal(t, `\\server\share\file.txt`, strings.ReplaceAll(tc.input, "/", `\`))
			} else {
				assert.Equal(t, tc.expected, result)
			}
		})
	}
}

// Test RegexOrString functionality
func TestRegexOrStringFunctionality(t *testing.T) {
	testCases := []struct {
		name        string
		pattern     string
		input       string
		ignoreCase  bool
		shouldMatch bool
		expectRegex bool
	}{
		{
			name:        "literal_match",
			pattern:     "file.txt",
			input:       "file.txt",
			ignoreCase:  false,
			shouldMatch: true,
			expectRegex: false,
		},
		{
			name:        "literal_case_insensitive",
			pattern:     "file.txt",
			input:       "FILE.TXT",
			ignoreCase:  true,
			shouldMatch: true,
			expectRegex: false,
		},
		{
			name:        "regex_match",
			pattern:     "file*.txt",
			input:       "file123.txt",
			ignoreCase:  false,
			shouldMatch: true,
			expectRegex: true,
		},
		{
			name:        "regex_no_match",
			pattern:     "file*.txt",
			input:       "document.pdf",
			ignoreCase:  false,
			shouldMatch: false,
			expectRegex: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			fs := setupLinuxFS()
			glob := NewGlob("test", fs)
			glob.IgnoreCase = tc.ignoreCase

			ros, err := glob.createRegexOrString(tc.pattern)
			require.NoError(t, err)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if ros.IsRegex != tc.expectRegex {
				t.Errorf("Expected IsRegex=%v, got %v", tc.expectRegex, ros.IsRegex)
			}

			match := ros.IsMatch(tc.input)
			if match != tc.shouldMatch {
				t.Errorf("Expected match=%v, got %v", tc.shouldMatch, match)
			}
		})
	}
}

--- END FILE: fsglob_internal_test.go ---

--- START FILE: fsglob_test.go ---
package fsglob_test

import (
	"fmt"
	"io"
	"io/fs"
	"os"
	"path"
	"strings"
	"testing"
	"time"

	"github.com/IgorBayerl/fsglob"
	"github.com/IgorBayerl/fsglob/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Cross-platform execution helper
func forPlatforms(t *testing.T, fn func(t *testing.T, fs *MockFilesystem)) {
	t.Helper()

	t.Run("unix", func(t *testing.T) {
		t.Parallel()
		fn(t, setupLinuxFS())
	})

	t.Run("windows", func(t *testing.T) {
		t.Parallel()
		fn(t, setupWindowsFS())
	})
}

// Mock filesystem
type MockFileInfo struct {
	name    string
	size    int64
	mode    fs.FileMode
	modTime time.Time
	isDir   bool
}

func (m MockFileInfo) Name() string       { return m.name }
func (m MockFileInfo) Size() int64        { return m.size }
func (m MockFileInfo) Mode() fs.FileMode  { return m.mode }
func (m MockFileInfo) ModTime() time.Time { return m.modTime }
func (m MockFileInfo) IsDir() bool        { return m.isDir }
func (m MockFileInfo) Sys() any           { return nil }

type MockDirEntry struct {
	name  string
	isDir bool
	info  MockFileInfo
}

func (m MockDirEntry) Name() string               { return m.name }
func (m MockDirEntry) IsDir() bool                { return m.isDir }
func (m MockDirEntry) Type() fs.FileMode          { return m.info.Mode() }
func (m MockDirEntry) Info() (fs.FileInfo, error) { return m.info, nil }

type MockFilesystem struct {
	files     map[string]MockFileInfo
	dirs      map[string][]MockDirEntry
	cwd       string
	platform  string
	separator string
}

func NewMockFilesystem(platform string) *MockFilesystem {
	sep := "/"
	cwd := "/"
	if platform == "windows" {
		sep = `\`
		cwd = `C:\`
	}
	fs := &MockFilesystem{
		files:     make(map[string]MockFileInfo),
		dirs:      make(map[string][]MockDirEntry),
		cwd:       cwd,
		platform:  platform,
		separator: sep,
	}
	// Add the root directory
	fs.AddFile(cwd, true)
	return fs
}

func (m *MockFilesystem) Platform() string { return m.platform }

func (m *MockFilesystem) mockClean(p string) string {
	isUnc := false
	if m.platform == "windows" {
		p = strings.ReplaceAll(p, `\`, `/`)
		if strings.HasPrefix(p, "//") {
			isUnc = true
			p = p[1:]
		}
	}
	cleaned := path.Clean(p)
	if m.platform == "windows" {
		if isUnc {
			cleaned = "/" + cleaned
		}
		cleaned = strings.ReplaceAll(cleaned, `/`, `\`)
		if len(cleaned) == 2 && cleaned[1] == ':' {
			cleaned += `\`
		}
	}
	return cleaned
}

func (m *MockFilesystem) Stat(name string) (fs.FileInfo, error) {
	absName, err := m.Abs(name)
	if err != nil {
		return nil, &fs.PathError{Op: "stat", Path: name, Err: err}
	}
	if info, exists := m.files[absName]; exists {
		return info, nil
	}
	if m.platform == "windows" {
		for p, info := range m.files {
			if strings.EqualFold(p, absName) {
				return info, nil
			}
		}
	}
	return nil, &fs.PathError{Op: "stat", Path: name, Err: fs.ErrNotExist}
}

func (m *MockFilesystem) ReadDir(name string) ([]fs.DirEntry, error) {
	abs, err := m.Abs(name)
	if err != nil {
		return nil, &fs.PathError{Op: "readdir", Path: name, Err: err}
	}

	handleFound := func(entries []MockDirEntry) ([]fs.DirEntry, error) {
		out := make([]fs.DirEntry, len(entries))
		for i := range entries {
			out[i] = entries[i]
		}
		return out, nil
	}

	if entries, ok := m.dirs[abs]; ok {
		return handleFound(entries)
	}

	if m.platform == "windows" {
		for p, entries := range m.dirs {
			if strings.EqualFold(p, abs) {
				return handleFound(entries)
			}
		}
	}

	// Before failing, check if 'name' is a file, which would also be an error for ReadDir
	if _, err := m.Stat(name); err == nil {
		return nil, &fs.PathError{Op: "readdir", Path: name, Err: fmt.Errorf("not a directory")}
	}

	return nil, &fs.PathError{Op: "readdir", Path: name, Err: fs.ErrNotExist}
}

func (m *MockFilesystem) Getwd() (string, error) { return m.cwd, nil }

func (m *MockFilesystem) isAbs(p string) bool {
	if m.platform == "windows" {
		return (len(p) > 2 && p[1] == ':' && (p[2] == '\\' || p[2] == '/')) || strings.HasPrefix(p, `\`) || strings.HasPrefix(p, `/`)
	}
	return strings.HasPrefix(p, "/")
}

func (m *MockFilesystem) Abs(path string) (string, error) {
	if m.platform == "windows" {
		path = strings.ReplaceAll(path, "/", `\`)
	} else {
		path = strings.ReplaceAll(path, `\`, "/")
	}

	if m.isAbs(path) {
		return m.mockClean(path), nil
	}

	fullPath := m.cwd + m.separator + path
	return m.mockClean(fullPath), nil
}

func (m *MockFilesystem) mockDir(p string) string {
	lastSep := strings.LastIndex(p, m.separator)
	if m.platform == "windows" {
		if len(p) == 3 && p[1] == ':' && p[2] == '\\' { // Is root, C:\
			return p
		}
	} else {
		if p == "/" {
			return p
		}
	}
	if lastSep <= 0 {
		return p[:1]
	}
	return p[:lastSep]
}

func (m *MockFilesystem) mockBase(p string) string {
	lastSep := strings.LastIndex(p, m.separator)
	if lastSep == -1 {
		return p
	}
	if m.platform == "windows" && lastSep == 2 && p[1] == ':' { // C:\ is base of C:\foo
		return p[lastSep+1:]
	}
	if lastSep == len(p)-1 {
		return ""
	}
	return p[lastSep+1:]
}

func (m *MockFilesystem) AddFile(path string, isDir bool) {
	abs, _ := m.Abs(path)
	info := MockFileInfo{
		name:    m.mockBase(abs),
		size:    100,
		mode:    0o644,
		modTime: time.Now(),
		isDir:   isDir,
	}
	if isDir {
		info.mode = fs.ModeDir | 0o755
		if _, exists := m.dirs[abs]; !exists {
			m.dirs[abs] = []MockDirEntry{}
		}
	}
	m.files[abs] = info

	parent := m.mockDir(abs)
	if parent != "" && parent != abs {
		entry := MockDirEntry{name: info.name, isDir: isDir, info: info}
		m.dirs[parent] = append(m.dirs[parent], entry)
	}
}

func (m *MockFilesystem) SetCwd(cwd string) {
	absCwd, _ := m.Abs(cwd)
	m.cwd = absCwd
}

// Stubbed-out methods not needed in these tests.
func (*MockFilesystem) MkdirAll(string, fs.FileMode) error          { return nil }
func (*MockFilesystem) Create(string) (io.WriteCloser, error)       { return nil, nil }
func (*MockFilesystem) Open(string) (fs.File, error)                { return nil, nil }
func (*MockFilesystem) ReadFile(string) ([]byte, error)             { return nil, nil }
func (*MockFilesystem) WriteFile(string, []byte, fs.FileMode) error { return nil }

// Test helper functions
func setupLinuxFS() *MockFilesystem {
	fs := NewMockFilesystem("unix")
	fs.SetCwd("/home/user")

	fs.AddFile("/home", true)
	fs.AddFile("/home/user", true)
	fs.AddFile("/home/user/documents", true)
	fs.AddFile("/home/user/documents/file1.txt", false)
	fs.AddFile("/home/user/documents/file2.txt", false)
	fs.AddFile("/home/user/documents/report.pdf", false)
	fs.AddFile("/home/user/documents/subdir", true)
	fs.AddFile("/home/user/documents/subdir/nested.txt", false)
	fs.AddFile("/home/user/documents/subdir/deep", true)
	fs.AddFile("/home/user/documents/subdir/deep/file.log", false)
	fs.AddFile("/home/user/pictures", true)
	fs.AddFile("/home/user/pictures/photo1.jpg", false)
	fs.AddFile("/home/user/pictures/photo2.png", false)
	fs.AddFile("/tmp", true)
	fs.AddFile("/tmp/temp1.tmp", false)
	fs.AddFile("/tmp/temp2.tmp", false)

	return fs
}

func setupWindowsFS() *MockFilesystem {
	fs := NewMockFilesystem("windows")
	fs.SetCwd("C:\\Users\\User")

	fs.AddFile("C:\\Users", true)
	fs.AddFile("C:\\Users\\User", true)
	fs.AddFile("C:\\Users\\User\\Documents", true)
	fs.AddFile("C:\\Users\\User\\Documents\\file1.txt", false)
	fs.AddFile("C:\\Users\\User\\Documents\\file2.txt", false)
	fs.AddFile("C:\\Users\\User\\Documents\\report.pdf", false)
	fs.AddFile("C:\\Users\\User\\Documents\\subdir", true)
	fs.AddFile("C:\\Users\\User\\Documents\\subdir\\nested.txt", false)
	fs.AddFile("C:\\Users\\User\\Documents\\subdir\\deep", true)
	fs.AddFile("C:\\Users\\User\\Documents\\subdir\\deep\\file.log", false)
	fs.AddFile("C:\\Users\\User\\Pictures", true)
	fs.AddFile("C:\\Users\\User\\Pictures\\photo1.jpg", false)
	fs.AddFile("C:\\Users\\User\\Pictures\\photo2.png", false)
	fs.AddFile("C:\\Temp", true)
	fs.AddFile("C:\\Temp\\temp1.tmp", false)
	fs.AddFile("C:\\Temp\\temp2.tmp", false)

	return fs
}

func TestExpandNames_BasicPatterns_ReturnExpected(t *testing.T) {
	t.Parallel()

	cases := []struct {
		name     string
		pattern  string
		wantUnix []string
		wantWin  []string
	}{
		{
			name:    "single asterisk",
			pattern: "documents/*.txt",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
			},
		},
		{
			name:    "question mark",
			pattern: "documents/file?.txt",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
			},
		},
		{
			name:    "double asterisk recursive",
			pattern: "documents/**/*.txt",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
				"/home/user/documents/subdir/nested.txt",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
				`C:\Users\User\Documents\subdir\nested.txt`,
			},
		},
		{
			name:    "character class",
			pattern: "documents/file[12].txt",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
			},
		},
		{
			name:    "brace expansion",
			pattern: "documents/{file1,file2}.txt",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
			},
		},
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
				// Arrange
				g := fsglob.NewGlob(tc.pattern, fs)

				// Act
				got, err := g.ExpandNames()

				// Assert
				require.NoError(t, err)
				want := tc.wantUnix
				if fs.platform == "windows" {
					want = tc.wantWin
				}
				testutil.PathsMatch(t, want, got)
			})
		})
	}
}

func TestExpandNames_AbsolutePaths_CorrectPerPlatform(t *testing.T) {
	t.Parallel()

	cases := []struct {
		name     string
		pattern  string
		wantUnix []string
		wantWin  []string
	}{
		{
			name:    "absolute path unix",
			pattern: "/home/user/documents/*.txt",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
			},
			wantWin: []string{}, // Should work differently on Windows
		},
		{
			name:     "absolute path windows",
			pattern:  `C:\Users\User\Documents\*.txt`,
			wantUnix: []string{}, // Should work differently on Unix
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
			},
		},
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
				// Arrange
				g := fsglob.NewGlob(tc.pattern, fs)

				// Act
				got, err := g.ExpandNames()

				// Assert
				require.NoError(t, err)
				want := tc.wantUnix
				if fs.platform == "windows" {
					want = tc.wantWin
				}
				testutil.PathsMatch(t, want, got)
			})
		})
	}
}

func TestExpandNames_RecursivePatterns_ReturnExpected(t *testing.T) {
	t.Parallel()

	cases := []struct {
		name     string
		pattern  string
		wantUnix []string
		wantWin  []string
	}{
		{
			name:    "recursive all files",
			pattern: "documents/**",
			wantUnix: []string{
				"/home/user/documents",
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
				"/home/user/documents/report.pdf",
				"/home/user/documents/subdir",
				"/home/user/documents/subdir/nested.txt",
				"/home/user/documents/subdir/deep",
				"/home/user/documents/subdir/deep/file.log",
			},
			wantWin: []string{
				`C:\Users\User\Documents`,
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
				`C:\Users\User\Documents\report.pdf`,
				`C:\Users\User\Documents\subdir`,
				`C:\Users\User\Documents\subdir\nested.txt`,
				`C:\Users\User\Documents\subdir\deep`,
				`C:\Users\User\Documents\subdir\deep\file.log`,
			},
		},
		{
			name:    "recursive specific extension",
			pattern: "**/*.txt",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
				"/home/user/documents/subdir/nested.txt",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
				`C:\Users\User\Documents\subdir\nested.txt`,
			},
		},
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
				// Arrange
				g := fsglob.NewGlob(tc.pattern, fs)

				// Act
				got, err := g.ExpandNames()

				// Assert
				require.NoError(t, err)
				want := tc.wantUnix
				if fs.platform == "windows" {
					want = tc.wantWin
				}
				testutil.PathsMatch(t, want, got)
			})
		})
	}
}

func TestExpandNames_InvalidGlob_ReturnsError(t *testing.T) {
	t.Parallel()

	cases := []struct {
		name    string
		pattern string
	}{
		{
			name:    "unbalanced braces",
			pattern: "documents/{file1,file2.txt",
		},
		{
			name:    "unterminated character class",
			pattern: "documents/file[12.txt",
		},
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
				// Arrange
				g := fsglob.NewGlob(tc.pattern, fs)

				// Act
				got, err := g.ExpandNames()

				// Assert
				assert.Error(t, err, "Expected an error for malformed pattern %q", tc.pattern)
				assert.Empty(t, got, "Expected empty results for malformed pattern")
			})
		})
	}
}

func TestExpandNames_NonGlobInputs_ReturnsPathOrEmpty(t *testing.T) {
	t.Parallel()

	cases := []struct {
		name     string
		pattern  string
		wantUnix []string
		wantWin  []string
	}{
		{
			name:     "empty pattern",
			pattern:  "",
			wantUnix: []string{},
			wantWin:  []string{},
		},
		{
			name:    "literal path exists",
			pattern: "documents/file1.txt",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
			},
		},
		{
			name:     "literal path doesn't exist",
			pattern:  "documents/nonexistent.txt",
			wantUnix: []string{},
			wantWin:  []string{},
		},
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
				// Arrange
				g := fsglob.NewGlob(tc.pattern, fs)

				// Act
				got, err := g.ExpandNames()

				// Assert
				require.NoError(t, err)
				want := tc.wantUnix
				if fs.platform == "windows" {
					want = tc.wantWin
				}
				testutil.PathsMatch(t, want, got)
			})
		})
	}
}

func TestExpandNames_NoMatch_ReturnsEmptySlice(t *testing.T) {
	t.Parallel()
	forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
		// Arrange
		g := fsglob.NewGlob("documents/*.nonexistent", fs)

		// Act
		got, err := g.ExpandNames()

		// Assert
		assert.NoError(t, err)
		assert.Empty(t, got, "Expected empty results for non-matching pattern")
	})
}

func TestExpandNames_LargeTree_FindsAllTxtFiles(t *testing.T) {
	t.Parallel()

	// Arrange
	fs := NewMockFilesystem("unix")
	fs.SetCwd("/home/user")
	fs.AddFile("/home", true)
	fs.AddFile("/home/user", true)
	fs.AddFile("/home/user/large", true)

	expectedCount := 0
	for i := 0; i < 100; i++ {
		fs.AddFile(fmt.Sprintf("/home/user/large/file%d.txt", i), false)
		expectedCount++
		if i%10 == 0 {
			fs.AddFile(fmt.Sprintf("/home/user/large/subdir%d", i), true)
			for j := 0; j < 10; j++ {
				fs.AddFile(fmt.Sprintf("/home/user/large/subdir%d/nested%d.txt", i, j), false)
				expectedCount++
			}
		}
	}

	g := fsglob.NewGlob("large/**/*.txt", fs)

	// Act
	got, err := g.ExpandNames()

	// Assert
	require.NoError(t, err)
	assert.Len(t, got, expectedCount, "Expected to find all .txt files in the large tree")
}

func TestExpandNames_CaseSensitivity_VariousFlags(t *testing.T) {
	t.Parallel()

	addExtraFiles := func(fs *MockFilesystem) {
		if fs.platform == "unix" {
			fs.AddFile("/home/user/documents/File1.TXT", false)
			fs.AddFile("/home/user/documents/FILE2.txt", false)
		} else {
			// On Windows mock, these are the same files, but AddFile with different cases
			// can test the case-insensitive lookup
			fs.AddFile(`C:\Users\User\Documents\File1.TXT`, false)
			fs.AddFile(`C:\Users\User\Documents\FILE2.txt`, false)
		}
	}

	cases := []struct {
		name       string
		pattern    string
		ignoreCase bool
		wantUnix   []string
		wantWin    []string
	}{
		{
			"mixed-case sensitive", "documents/*.TXT", false,
			[]string{"/home/user/documents/File1.TXT"},
			[]string{`C:\Users\User\Documents\File1.TXT`},
		},
		{
			"mixed-case insensitive", "documents/*.TXT", true,
			[]string{"/home/user/documents/file1.txt", "/home/user/documents/file2.txt", "/home/user/documents/File1.TXT", "/home/user/documents/FILE2.txt"},
			[]string{`C:\Users\User\Documents\file1.txt`, `C:\Users\User\Documents\file2.txt`, `C:\Users\User\Documents\File1.TXT`, `C:\Users\User\Documents\FILE2.txt`},
		},
		{
			"lower-case sensitive", "documents/*.txt", false,
			[]string{"/home/user/documents/file1.txt", "/home/user/documents/file2.txt", "/home/user/documents/FILE2.txt"},
			[]string{`C:\Users\User\Documents\file1.txt`, `C:\Users\User\Documents\file2.txt`, `C:\Users\User\Documents\FILE2.txt`},
		},
		{
			"lower-case insensitive", "documents/*.txt", true,
			[]string{"/home/user/documents/file1.txt", "/home/user/documents/file2.txt", "/home/user/documents/File1.TXT", "/home/user/documents/FILE2.txt"},
			[]string{`C:\Users\User\Documents\file1.txt`, `C:\Users\User\Documents\file2.txt`, `C:\Users\User\Documents\File1.TXT`, `C:\Users\User\Documents\FILE2.txt`},
		},
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
				// Arrange
				addExtraFiles(fs)
				g := fsglob.NewGlob(tc.pattern, fs, fsglob.WithIgnoreCase(tc.ignoreCase))

				// Act
				got, err := g.ExpandNames()

				// Assert
				require.NoError(t, err)
				want := tc.wantUnix
				if fs.platform == "windows" {
					want = tc.wantWin
				}
				testutil.PathsMatch(t, want, got)
			})
		})
	}
}

func TestExpandNames_ComplexBraceExpansion_ReturnsExpected(t *testing.T) {
	t.Parallel()

	cases := []struct {
		name     string
		pattern  string
		wantUnix []string
		wantWin  []string
	}{
		{
			name:    "nested braces",
			pattern: "documents/{file{1,2},report}.{txt,pdf}",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
				"/home/user/documents/report.pdf",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
				`C:\Users\User\Documents\report.pdf`,
			},
		},
		{
			name:    "cross-separator braces",
			pattern: "{documents,pictures}/*.{txt,jpg}",
			wantUnix: []string{
				"/home/user/documents/file1.txt",
				"/home/user/documents/file2.txt",
				"/home/user/pictures/photo1.jpg",
			},
			wantWin: []string{
				`C:\Users\User\Documents\file1.txt`,
				`C:\Users\User\Documents\file2.txt`,
				`C:\Users\User\Pictures\photo1.jpg`,
			},
		},
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
				// Arrange
				g := fsglob.NewGlob(tc.pattern, fs)

				// Act
				got, err := g.ExpandNames()

				// Assert
				require.NoError(t, err)
				want := tc.wantUnix
				if fs.platform == "windows" {
					want = tc.wantWin
				}
				testutil.PathsMatch(t, want, got)
			})
		})
	}
}

func TestExpandNames_DotAndDotDot_Patterns(t *testing.T) {
	t.Parallel()

	t.Run("current_directory", func(t *testing.T) {
		t.Parallel()
		forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
			// Arrange
			g := fsglob.NewGlob(".", fs)

			// Act
			got, err := g.ExpandNames()

			// Assert
			require.NoError(t, err)
			expectedCwd, _ := fs.Getwd()
			testutil.PathsMatch(t, []string{expectedCwd}, got)
		})
	})

	t.Run("parent_directory", func(t *testing.T) {
		t.Parallel()
		forPlatforms(t, func(t *testing.T, fs *MockFilesystem) {
			// Arrange
			g := fsglob.NewGlob("..", fs)

			// Act
			got, err := g.ExpandNames()

			// Assert
			require.NoError(t, err)
			cwd, _ := fs.Getwd()
			expectedParent := fs.mockDir(cwd)
			testutil.PathsMatch(t, []string{expectedParent}, got)
		})
	})
}

func TestGetFilesPublicAPI(t *testing.T) {
	t.Parallel()

	// Arrange
	dir := t.TempDir()
	cwd, err := os.Getwd()
	require.NoError(t, err) // Use require for test setup
	defer func() {
		err := os.Chdir(cwd)
		require.NoError(t, err, "failed to change back to original directory")
	}()

	err = os.Chdir(dir)
	require.NoError(t, err)

	// Act
	results, err := fsglob.GetFiles("*.nonexistent")

	// Assert
	require.NoError(t, err)
	assert.Empty(t, results, "expected empty results for non-matching pattern")

	// Act
	results, err = fsglob.GetFiles("")

	// Assert
	require.NoError(t, err)
	assert.Empty(t, results, "expected empty results for empty pattern")
}

--- END FILE: fsglob_test.go ---

--- START FILE: go.mod ---
module github.com/IgorBayerl/fsglob

go 1.23.5

require (
	github.com/google/go-cmp v0.7.0
	github.com/stretchr/testify v1.10.0
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

--- END FILE: go.mod ---

--- START FILE: testutil/assert.go ---
package testutil

import (
	"path/filepath"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/stretchr/testify/assert"
)

// CmpPaths is a cmp.Option bundle that normalizes path separators to '/'
// and sorts string slices before comparison. This is ideal for comparing
// lists of file paths in a cross-platform, order-insensitive way.
var CmpPaths = cmp.Options{
	cmp.Transformer("toSlash", filepath.ToSlash),
	cmpopts.SortSlices(func(a, b string) bool { return a < b }),
}

// PathsMatch asserts that two string slices containing file paths are equivalent,
// ignoring slice order and path separator differences (e.g., '\' vs '/').
//
// It uses go-cmp for its powerful diffing capabilities and reports the
// failure using the testify/assert framework for consistent test output.
//
// Returns true if the paths match, false otherwise.
func PathsMatch(t *testing.T, want, got []string, msgAndArgs ...interface{}) bool {
	t.Helper()

	// Use go-cmp to compare the slices with our custom options
	diff := cmp.Diff(want, got, CmpPaths...)

	if diff == "" {
		return true // The slices are equivalent, assertion passes.
	}

	// The slices are different. Report the failure using testify.
	// This ensures the test output format is consistent with other testify assertions.
	assert.Fail(t, "Path lists do not match.", "(-want +got):\n%s", diff)
	return false
}

--- END FILE: testutil/assert.go ---

